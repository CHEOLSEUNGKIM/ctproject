<!DOCTYPE html>
<html lang="en" style="height:100%;">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=600, initial-scale=1.0" />
  <title>배드민턴 포지셔닝 시뮬레이터</title>
  <style>
    html, body {
      height: 100%;
      overflow-y: auto;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      background: #f2f2f2;
      min-height: 100vh;
      box-sizing: border-box;
      overflow-y: auto;
    }
    #layout { display: flex; flex-direction: row; align-items: flex-start; justify-content: center; margin-top: 16px; }
    #mainPanel { min-width: 450px; }
    #sidePanel {
      min-width: 316px; max-width: 360px; width: 340px; padding-left: 20px;
      height: 715px; box-sizing: border-box; display: flex; flex-direction: column; align-items: flex-start;
      overflow-x: auto;
    }
    #court { position: relative; width: 400px; height: 600px; background-color: #e0f7fa; margin: 20px auto 0 auto; border: 2px solid #000; box-shadow: 1px 2px 11px #cfebf5; }
    #centerLine { position: absolute; border-left: 2px solid #1976D2; height: 100%; left: 50%; top: 0; transform: translateX(-1px); opacity: 0.8; z-index: 9; pointer-events: none;}
    .player { position: absolute; width: 60px; height: 30px; background-color: #ffcc80; border: 1px solid #000; text-align: center; line-height: 30px; border-radius: 5px; font-size: 16px; font-weight: bold; cursor: pointer; transition: outline 0.15s; user-select: none;}
    #net { position: absolute; width: 100%; height: 4px; background-color: #000; top: 50%; left: 0; transform: translateY(-2px); z-index: 11;}
    #shuttlecock { position: absolute; width: 15px; height: 15px; background-color: red; border-radius: 50%; display: none; z-index: 12; }
    select, button { margin: 5px; font-size: 15px;}
    #log { margin-top: 18px; text-align: left; width: 400px; margin-left: auto; margin-right: auto; min-height: 42px; font-size: 15px;}
    #shotHistoryContainer { width: 100%; padding-top: 10px; }
    #shotHistoryList {
      width: 100%; min-height: 60px; max-height: 330px; background: #fff; box-shadow: 0 0 8px #cdeefa34; border-radius: 7px;
      padding: 12px 8px 12px 18px; margin-bottom: 40px; font-size: 15px; overflow-y: auto; box-sizing: border-box;
    }
    #shotHistoryTitle { font-weight: bold; font-size: 17px; color: #1668b3; margin-bottom: 12px; margin-top: 2px;}
    .shotItem { margin-bottom: 6px;}
    #swapButtons { margin-top: 12px; text-align: center;}
    /* 조건 안내 스타일 */
    .rule-notice {
      background: #e7f4ff;
      border: 1px solid #79a5d3;
      border-radius: 7px;
      padding: 15px 16px;
      margin: 22px auto 6px auto;
      width: 95%;
      max-width: 670px;
      font-size: 16px;
      line-height: 1.7;
      color: #12497a;
    }
    .rule-notice strong { color: #1976D2; font-weight: bold;}
  </style>
</head>
<body>
  <!-- 규칙 조건 및 안내문 수정 -->
  <div class="rule-notice">
    <strong>📝 스트로크 루틴 작성 조건</strong><br>
    1. 모둠은 <strong>총 10개의 스트로크(<u>서브 포함</u>)</strong>를 작성해야 합니다.<br>
    2. <strong>각 학생(선수)당 최소 2개의 서로 다른 기술(<u>서브 제외</u>)</strong>을 수행해야 합니다.<br>
    <span style="color:#cf174b">⚠️ '숏 서브', '롱 서브'는 2번 조건 기술 개수 산정에서 제외합니다.</span>
  </div>
  <h2 style="text-align:center;">배드민턴 포지셔닝 시뮬레이터</h2>
  <div id="layout">
    <div id="mainPanel">
      <div style="margin-bottom: 2px;">
        <input type="text" id="playerAName" placeholder="선수 A 이름" />
        <input type="text" id="playerBName" placeholder="선수 B 이름" />
        <input type="text" id="playerCName" placeholder="선수 C 이름" />
        <input type="text" id="playerDName" placeholder="선수 D 이름" />
        <button onclick="setPlayerNames()">이름 설정하기</button>
      </div>
      <div>
        <select id="senderSelect"></select>
        <select id="receiverSelect"></select>
        <select id="skillSelect">
          <option value="숏 서브">숏 서브</option>
          <option value="롱 서브">롱 서브</option>
          <option value="드롭">드롭</option>
          <option value="스매시">스매시</option>
          <option value="헤어핀">헤어핀</option>
          <option value="드라이브">드라이브</option>
          <option value="언더클리어">언더클리어</option>
          <option value="하이클리어">하이클리어</option>
          <option value="커트 수비">커트 수비</option>
          <option value="클리어 수비">클리어 수비</option>
        </select>
        <button onclick="executeSkill()">기술 사용</button>
        <button onclick="goBack()">이전</button>
        <button onclick="resetAll()">초기화</button>
        <button onclick="playSampleShots()" id="replayShotBtn">샷 재생</button>
        <button onclick="generateSampleData()">샘플 데이터 생성</button>
        <!-- 검증 버튼 추가 -->
        <button onclick="validateRoutine()" style="margin-left:18px; background:#1976d2;color:#fff; font-weight:bold;">루틴 검증</button>
      </div>
      <div id="court">
        <div id="centerLine"></div>
        <div id="net"></div>
        <div id="shuttlecock"></div>
        <div class="player" id="A"></div>
        <div class="player" id="B"></div>
        <div class="player" id="C"></div>
        <div class="player" id="D"></div>
      </div>
      <div id="swapButtons">
        <button onclick="swapPositions('AB')">AB 위치 바꾸기</button>
        <button onclick="swapPositions('CD')">CD 위치 바꾸기</button>
      </div>
      <div id="log"></div>
    </div>
    <div id="sidePanel">
      <div id="shotHistoryContainer">
        <div id="shotHistoryTitle">샷(스트로크) 순차 기록</div>
        <div id="shotHistoryList"></div>
      </div>
    </div>
  </div>
  <script>
    // ----------- 기존 변수/상수 및 함수 그대로 -----------
    const skillList = [
      "숏 서브","롱 서브","드롭","스매시","헤어핀","드라이브","언더클리어","하이클리어","커트 수비","클리어 수비"
    ];
    const D_REAR_SHOTS = ["스매시","드롭","하이클리어"];
    const ONLY_NET_RESPONDABLE_PREV = ["숏 서브","드롭","헤어핀","커트 수비"];
    const ONLY_NET_RESPONDERS = ["언더클리어", "헤어핀"];
    const ONLY_REAR_RESPONDABLE_PREV = ["하이클리어", "언더클리어", "클리어 수비", "롱 서브"];
    const ONLY_REAR_RESPONDERS = ["스매시", "드롭", "하이클리어", "드라이브"];
    const DROPPABLE_PREV = ONLY_REAR_RESPONDABLE_PREV;
    const SMASH_PREV = ["스매시"];
    const SMASH_RESPONDERS = ["커트 수비", "클리어 수비"];
    const DRIVE_PREV = ["드라이브"];
    const DRIVE_RESPONDERS = ["커트 수비", "클리어 수비", "드라이브"];
    const players = {
      A: { name: 'A', team: 'AB' },
      B: { name: 'B', team: 'AB' },
      C: { name: 'C', team: 'CD' },
      D: { name: 'D', team: 'CD' },
    };
    let history = [];
    let manualPositions = {
      A: [100, 520], B: [300, 520],
      C: [100, 50],  D: [300, 50]
    };
    let selectedPlayerId = null;
    let draggingPlayer = null, dragOffsetX=0, dragOffsetY=0;

    function onPlayerMouseDown(e) {
      draggingPlayer = e.target.id;
      const rect = e.target.getBoundingClientRect();
      const courtRect = document.getElementById('court').getBoundingClientRect();
      dragOffsetX = e.clientX - rect.left;
      dragOffsetY = e.clientY - rect.top;
      document.addEventListener('mousemove', playerDragMove);
      document.addEventListener('mouseup', playerDragEnd);
      e.preventDefault();
    }
    function playerDragMove(e) {
      if (!draggingPlayer) return;
      const court = document.getElementById('court');
      const courtRect = court.getBoundingClientRect();
      let minX = 0, minY = 0, maxX = court.offsetWidth - 60, maxY = court.offsetHeight - 30;
      let x = e.clientX - courtRect.left - dragOffsetX;
      let y = e.clientY - courtRect.top - dragOffsetY;
      x = Math.max(minX, Math.min(maxX, x));
      y = Math.max(minY, Math.min(maxY, y));
      const elem = document.getElementById(draggingPlayer);
      elem.style.left = x + 'px';
      elem.style.top = y + 'px';
      manualPositions[draggingPlayer] = [x, y];
    }
    function playerDragEnd(e) {
      draggingPlayer = null;
      document.removeEventListener('mousemove', playerDragMove);
      document.removeEventListener('mouseup', playerDragEnd);
    }
    function clearAllOutlines() {
      for (let id of ['A','B','C','D']) document.getElementById(id).style.outline = "";
    }
    function onPlayerClick(e) {
      if (draggingPlayer) return;
      const id = e.target.id;
      if (!selectedPlayerId) {
        selectedPlayerId = id;
        clearAllOutlines();
        document.getElementById(id).style.outline = "3px solid #1976D2";
      } else if (selectedPlayerId && selectedPlayerId !== id) {
        const temp = [...manualPositions[selectedPlayerId]];
        manualPositions[selectedPlayerId] = [...manualPositions[id]];
        manualPositions[id] = temp;
        updatePositions();
        clearAllOutlines();
        selectedPlayerId = null;
      } else {
        clearAllOutlines();
        selectedPlayerId = null;
      }
    }
    function setPlayerNames() {
      players.A.name = document.getElementById('playerAName').value || 'A';
      players.B.name = document.getElementById('playerBName').value || 'B';
      players.C.name = document.getElementById('playerCName').value || 'C';
      players.D.name = document.getElementById('playerDName').value || 'D';
      updateDropdowns();
      updatePositions();
      renderShotHistory();
    }
    function updateDropdowns() {
      const senderSelect = document.getElementById('senderSelect');
      const receiverSelect = document.getElementById('receiverSelect');
      senderSelect.innerHTML = '';
      receiverSelect.innerHTML = '';
      for (const key in players) {
        const p = players[key];
        const senderOption = new Option(p.name, key);
        senderSelect.appendChild(senderOption);
      }
      updateReceiverOptions();
      senderSelect.onchange = updateReceiverOptions;
    }
    function updateReceiverOptions() {
      const sender = document.getElementById('senderSelect').value;
      const receiverSelect = document.getElementById('receiverSelect');
      receiverSelect.innerHTML = '';
      for (const key in players) {
        if (key !== sender && players[sender].team !== players[key].team) {
          const option = new Option(players[key].name, key);
          receiverSelect.appendChild(option);
        }
      }
    }
    function updatePositions() {
      for (const id of ['A','B','C','D']) {
        const [x, y] = manualPositions[id];
        const elem = document.getElementById(id);
        elem.style.left = x + 'px';
        elem.style.top = y + 'px';
        elem.textContent = players[id].name;
      }
      clearAllOutlines();
      selectedPlayerId = null;
    }
    function executeSkill() {
      const sender = document.getElementById('senderSelect').value;
      const receiver = document.getElementById('receiverSelect').value;
      const skill = document.getElementById('skillSelect').value;
      history.push({ sender, receiver, skill });
      renderShotHistory();
      animateShuttle(sender, receiver);
      applyPositioning(sender, receiver, skill);
      document.getElementById('senderSelect').value = receiver;
      updateReceiverOptions();
    }
    function applyPositioning(sender, receiver, skill) {
      const teamSender = players[sender].team;
      const partnerSender = Object.keys(players).find(p => players[p].team === teamSender && p !== sender);
      const teamReceiver = players[receiver].team;
      const partnerReceiver = Object.keys(players).find(p => players[p].team === teamReceiver && p !== receiver);
      let pos = {...manualPositions};
      if (["하이클리어", "언더클리어", "클리어 수비", "롱 서브"].includes(skill)) {
        if (teamSender === 'AB') { pos.A = [100, 520]; pos.B = [300, 520]; }
        else { pos.C = [100, 50]; pos.D = [300, 50]; }
        if (teamReceiver === 'AB') {
          pos[receiver] = [200, 550]; pos[partnerReceiver] = [200, 480];
        } else {
          if(receiver === "D") { pos.D = [200, 20]; pos.C = [200, 90]; }
          else { pos[receiver] = [200, 20]; pos[partnerReceiver] = [200, 90]; }
        }
      }
      else if (skill === "커트 수비") {
        if (teamSender === 'AB') {
          pos[sender] = [200, 480]; pos[partnerSender] = [200, 550];
        } else {
          pos[sender] = [200, 90]; pos[partnerSender] = [200, 20];
        }
      }
      else if (skill === "숏 서브") {
        if (teamSender === 'AB') {
          pos[sender] = [200, 480]; pos[partnerSender] = [200, 550];
        } else {
          pos[sender] = [200, 90];  pos[partnerSender] = [200, 20];
        }
      }
      else if (skill === "헤어핀") {
        if (teamSender === 'AB') {
          pos[sender] = [300, 480]; pos[partnerSender] = [100, 550];
        } else {
          pos[sender] = [200, 90];  pos[partnerSender] = [200, 20];
        }
      }
      // ★★★ 스매시(중앙 세로), 드롭/드라이브(벌어짐) 각각 분리
      else if (["스매시", "드롭", "드라이브"].includes(skill)) {
        if (teamSender === 'AB') {
          if (skill === '스매시') {
            pos[sender] = [200, 550];
            pos[partnerSender] = [200, 480];
          } else {
            pos[sender] = [100, 550];
            pos[partnerSender] = [300, 480];
          }
        } else {
          if (sender === 'D') {
            if (skill === '스매시') {
              pos.D = [200, 20];
              pos.C = [200, 90];
            } else {
              pos.D = [200, 20];
              pos.C = [200, 90];
            }
          } else {
            if (skill === '스매시') {
              pos[sender] = [200, 20];
              pos[partnerSender] = [200, 90];
            } else {
              pos[sender] = [100, 20];
              pos[partnerSender] = [300, 90];
            }
          }
        }
      }
      else {
        if (teamSender === 'AB') {
          pos[sender] = [100, 550]; pos[partnerSender] = [300, 480];
        } else {
          pos[sender] = [100, 20]; pos[partnerSender] = [300, 90];
        }
      }
      for(let k of ['A','B','C','D']) manualPositions[k] = [...pos[k]];
      updatePositions();
    }
    function swapPositions(team) {
      if(team === 'AB') [manualPositions.A, manualPositions.B] = [manualPositions.B, manualPositions.A];
      else [manualPositions.C, manualPositions.D] = [manualPositions.D, manualPositions.C];
      updatePositions();
    }
    function animateShuttle(from, to) {
      const fromElem = document.getElementById(from);
      const toElem = document.getElementById(to);
      const shuttle = document.getElementById('shuttlecock');
      const fromX = fromElem.offsetLeft + 20;
      const fromY = fromElem.offsetTop + 10;
      const toX = toElem.offsetLeft + 20;
      const toY = toElem.offsetTop + 10;
      shuttle.style.left = fromX + 'px';
      shuttle.style.top = fromY + 'px';
      shuttle.style.display = 'block';
      shuttle.animate([
        { left: fromX + 'px', top: fromY + 'px' },
        { left: toX + 'px', top: toY + 'px' }
      ], { duration: 1200, fill: 'forwards' });
      setTimeout(() => { shuttle.style.display = 'none'; }, 1300);
    }
    function goBack() {
      history.pop();
      document.getElementById('log').innerHTML = '';
      manualPositions = {A: [100, 520], B: [300, 520], C: [100, 50], D: [300, 50]};
      if(history.length > 0) {
        history.forEach(({ sender, receiver, skill }) => { applyPositioning(sender, receiver, skill); });
      } else updatePositions();
      renderShotHistory();
    }
    function resetAll() {
      history = [];
      document.getElementById('log').innerHTML = '';
      manualPositions = {A: [100, 520], B: [300, 520], C: [100, 50], D: [300, 50]};
      updatePositions();
      renderShotHistory();
    }
    function renderShotHistory() {
      const shotListDiv = document.getElementById('shotHistoryList');
      shotListDiv.innerHTML = history.length === 0
        ? `<div style="color:#89a0b8;font-size:15px;">아직 샷 기록이 없습니다.</div>`
        : history.slice().reverse().map(
            ({sender, receiver, skill}) =>
              `<div class="shotItem"><span style="color:#1668b3;font-weight:bold;">${players[sender].name}</span> &rarr; <span style="color:#e66413;">${players[receiver].name}</span> : <span style="color:#1976d2;">${skill}</span></div>`
          ).join('');
    }
    let playingShot = false;
    async function playSampleShots() {
      if (playingShot) return;
      if (!history.length) return;
      playingShot = true;
      document.getElementById('replayShotBtn').disabled = true;
      manualPositions = {A: [100, 520], B: [300, 520], C: [100, 50], D: [300, 50]};
      updatePositions();
      await delay(800);
      for (let i = 0; i < history.length; i++) {
        const {sender, receiver, skill} = history[i];
        animateShuttle(sender, receiver);
        applyPositioning(sender, receiver, skill);
        highlightShotInHistory(i);
        await delay(1700);
      }
      highlightShotInHistory(-1);
      playingShot = false;
      document.getElementById('replayShotBtn').disabled = false;
    }
    function delay(ms) { return new Promise(r => setTimeout(r, ms)); }
    function highlightShotInHistory(idx) {
      const listDiv = document.getElementById('shotHistoryList');
      const nodes = listDiv.querySelectorAll('.shotItem');
      nodes.forEach((node, i) => {
        node.style.background = (history.length-1-i === idx) ? 'rgba(28,181,213,0.10)' : '';
        node.style.fontWeight = (history.length-1-i === idx) ? 'bold' : '';
      });
    }
    function generateSampleData() {
      const skillOrderLimitPerPlayer = 2;
      const teamPlayers = { 'A-B': ['A','B'], 'C-D':['C','D'] };
      let seq = [];
      let rallyUsedCounts = {A:0, B:0, C:0, D:0};
      let firstServer = Math.random() < 0.5 ? "A" : "B";
      let firstReceiver = Math.random() < 0.5 ? "C" : "D";
      seq.push({sender: firstServer, receiver: firstReceiver, team: 'A-B'});
      rallyUsedCounts[firstServer]++;
      let lastReceiver = firstReceiver;
      for(let i=1;i<10;i++){
        let thisTeam = seq[i-1].team === 'A-B' ? 'C-D' : 'A-B';
        let sender = lastReceiver;
        rallyUsedCounts[sender]++;
        let otherTeam = (thisTeam==='A-B')?'C-D':'A-B';
        let receiverCandidates = teamPlayers[otherTeam].filter(p => p !== sender);
        let receiver = receiverCandidates[Math.floor(Math.random()*receiverCandidates.length)];
        seq.push({sender, receiver, team: thisTeam});
        lastReceiver = receiver;
      }
      const sample = [];
      const used = {A:[], B:[], C:[], D:[]};
      let prevSkill = null;
      for (let i = 0; i < seq.length; i++) {
        const {sender, receiver, team} = seq[i];
        let skill;
        if (i === 0) {
          skill = (Math.random() < 0.8) ? '숏 서브' : '롱 서브';
        } else {
          let allowedSkills = skillList.filter(
            s => s !== "숏 서브" && s !== "롱 서브" && !used[sender].includes(s)
          );
          if (i > 0) {
            const prevSample = sample[i-1];
            if (prevSample && SMASH_PREV.includes(prevSample.skill)) {
              allowedSkills = allowedSkills.filter(s => SMASH_RESPONDERS.includes(s));
            }
            else if (prevSample && DRIVE_PREV.includes(prevSample.skill)) {
              allowedSkills = allowedSkills.filter(s => DRIVE_RESPONDERS.includes(s));
            }
            else if (prevSample && ONLY_NET_RESPONDABLE_PREV.includes(prevSample.skill)) {
              allowedSkills = allowedSkills.filter(s => ONLY_NET_RESPONDERS.includes(s));
            }
            if (allowedSkills.includes("드롭") && (!prevSample || !DROPPABLE_PREV.includes(prevSample.skill))) {
              allowedSkills = allowedSkills.filter(s => s !== "드롭");
            }
            else if (prevSample && ONLY_REAR_RESPONDABLE_PREV.includes(prevSample.skill)) {
              allowedSkills = allowedSkills.filter(s => ONLY_REAR_RESPONDERS.includes(s));
            }
          }
          if (allowedSkills.includes("클리어 수비") || allowedSkills.includes("커트 수비")) {
            const lastSkillWasSmash = prevSkill === "스매시";
            allowedSkills = allowedSkills.filter(s => (s === "클리어 수비" || s === "커트 수비") ? lastSkillWasSmash : true );
          }
          if (
            (i === 1 && prevSkill === "롱 서브") ||
            (prevSkill === "롱 서브" && seq[i-1].team !== seq[i].team)
          ) {
            allowedSkills = allowedSkills.filter(s => ["하이클리어", "스매시", "드롭"].includes(s));
          }
          if (team === "C-D" && sender === "D" && isCDRearSituation(sample, i)) {
            allowedSkills = allowedSkills.filter(s => D_REAR_SHOTS.includes(s));
          }
          skill = allowedSkills.length > 0 ? allowedSkills[Math.floor(Math.random() * allowedSkills.length)] : "언더클리어";
        }
        used[sender].push(skill);
        sample.push({ sender, receiver, skill });
        prevSkill = skill;
      }
      history = sample.slice();
      manualPositions = {A: [100, 520], B: [300, 520], C: [100, 50], D: [300, 50]};
      document.getElementById('log').innerHTML = '';
      sample.forEach(({sender, receiver, skill}) => { applyPositioning(sender, receiver, skill); });
      renderShotHistory();
      updateDropdowns();
      updatePositions();
    }
    function isCDRearSituation(sample, idx) { return idx !== 0; }
    window.addEventListener('DOMContentLoaded', () => {
      for (let id of ['A','B','C','D']) {
        document.getElementById(id).addEventListener('mousedown', onPlayerMouseDown);
        document.getElementById(id).addEventListener('click', onPlayerClick);
      }
      setPlayerNames();
      updatePositions();
    });

    // ----------- 아래부터 검증 기능(조건만 수정) -----------
    function validateRoutine() {
      // 1. 서브 포함 10개의 스트로크를 했는지 검사
      const strokeCount = history.length;

      // 2. 한 명당 최소 2개 이상의 서로 다른 "서브 제외" 기술 사용 체크
      // ('숏 서브', '롱 서브'는 제외)
      const skillPerPlayer = {A: new Set(), B: new Set(), C: new Set(), D: new Set()};
      for (const item of history) {
        if(item.skill === "숏 서브" || item.skill === "롱 서브") continue;
        skillPerPlayer[item.sender].add(item.skill);
      }

      let errorMsgList = [];
      if (strokeCount !== 10) {
        errorMsgList.push(
          `스트로크(서브 포함) 개수가 ${strokeCount}개입니다. 총 10개의 스트로크를 작성해야 합니다.`
        );
      }
      for (const id of ['A','B','C','D']) {
        if (skillPerPlayer[id].size < 2) {
          errorMsgList.push(
            `${players[id].name} 선수는 (서브 제외) 두 개 이상의 <서로 다른> 기술을 수행해야 합니다. (현재: ${[...skillPerPlayer[id]].join(', ') || '없음'})`
          );
        }
      }
      // 결과 안내 (alert 팝업)
      if (errorMsgList.length === 0) {
        alert("🙆‍♂️ 루틴이 조건을 모두 만족합니다! 잘 짰어요!");
      } else {
        alert("❌ 스트로크 루틴 오류\n\n" + errorMsgList.join('\n'));
      }
    }
  </script>
</body>
</html>
